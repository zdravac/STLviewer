"""
Main viewer class for STL/3MF viewer
"""
import vtk
from PyQt6.QtCore import QObject, pyqtSignal
from dataclasses import dataclass
from typing import Dict, Optional, List
import os
import traceback
from parser_3mf import load_3mf, Object3MF
from screenshot_tools import ScreenshotTools
from object_manager import ObjectProperties

@dataclass
class ModelStats:
    """Statistics about a 3D model"""
    vertices: int
    faces: int
    volume: float
    surface_area: float

class ModelViewer(QObject):
    """Main viewer class for 3D models"""
    model_loaded = pyqtSignal(bool)
    model_stats_updated = pyqtSignal(object)  # ModelStats
    object_properties_changed = pyqtSignal(object)  # ObjectProperties

    def __init__(self, renderer: vtk.vtkRenderer):
        super().__init__()
        self.renderer = renderer
        self.actors: Dict[str, vtk.vtkActor] = {}
        
        # Set up renderer
        self.renderer.SetBackground(0.2, 0.2, 0.2)  # Dark gray
        self.renderer.SetUseDepthPeeling(1)
        self.renderer.SetMaximumNumberOfPeels(8)
        self.renderer.SetOcclusionRatio(0.0)
        
        # Enable two-sided lighting
        self.renderer.SetTwoSidedLighting(True)
        
        # Enable shadows
        self.renderer.SetUseShadows(True)
        
        # Create tools
        self.screenshot_tools = None
        
        # Set up lighting
        self._setup_lighting()
        
        # Set better default camera position
        camera = self.renderer.GetActiveCamera()
        camera.SetPosition(1, 1, 1)
        camera.SetFocalPoint(0, 0, 0)
        camera.SetViewUp(0, 1, 0)
        camera.SetViewAngle(30.0)

    def initialize_tools(self, parent_widget):
        """Initialize tools"""
        self.screenshot_tools = ScreenshotTools(self.renderer.GetRenderWindow(), parent_widget)

    def load_stl(self, file_path: str) -> bool:
        """Load an STL file"""
        try:
            print(f"Loading STL file: {file_path}")
            
            # Clear existing scene and reset lighting
            self.clear_scene()
            self.renderer.RemoveAllViewProps()
            self._setup_lighting()
            
            # Create reader
            reader = vtk.vtkSTLReader()
            reader.SetFileName(file_path)
            print("Reading STL file...")
            reader.Update()
            
            output = reader.GetOutput()
            if not output or output.GetNumberOfPoints() == 0:
                raise ValueError("STL file contains no points")
            
            print(f"Loaded {output.GetNumberOfPoints()} points and {output.GetNumberOfCells()} cells")
            
            # Create mapper
            mapper = vtk.vtkPolyDataMapper()
            mapper.SetInputConnection(reader.GetOutputPort())
            mapper.ScalarVisibilityOff()
            
            # Create actor with default properties
            actor = vtk.vtkActor()
            actor.SetMapper(mapper)
            
            prop = actor.GetProperty()
            prop.SetColor(0.8, 0.8, 0.8)  # Light gray
            prop.SetAmbient(0.1)
            prop.SetDiffuse(0.7)
            prop.SetSpecular(0.2)
            prop.SetSpecularPower(30.0)
            
            # Add to scene
            self.renderer.AddActor(actor)
            name = os.path.basename(file_path)
            self.actors[name] = actor
            
            # Create and emit object properties
            props = ObjectProperties(
                name=name,
                visible=True,
                color=(0.8, 0.8, 0.8),
                opacity=1.0,
                wireframe=False,
                cast_shadows=True,
                receive_shadows=True
            )
            self.object_properties_changed.emit(props)
            
            # Update statistics
            self._update_stats(output)
            
            # Reset camera and render
            self.reset_view()
            self.renderer.ResetCameraClippingRange()
            self.renderer.GetRenderWindow().Render()
            
            print("STL file loaded successfully")
            self.model_loaded.emit(True)
            return True
            
        except Exception as e:
            traceback.print_exc()
            print(f"Error loading STL: {e}")
            self.model_loaded.emit(False)
            return False

    def load_3mf(self, file_path: str) -> bool:
        """Load a 3MF file"""
        try:
            # Clear existing models
            self.clear_scene()
            
            # Load 3MF objects
            objects = load_3mf(file_path)
            
            for obj in objects:
                # Create mapper
                mapper = vtk.vtkPolyDataMapper()
                mapper.SetInputData(obj.mesh)
                
                # Create actor
                actor = vtk.vtkActor()
                actor.SetMapper(mapper)
                
                # Apply transform if exists
                if obj.transform:
                    transform = vtk.vtkTransform()
                    transform.SetMatrix(obj.transform)
                    actor.SetUserTransform(transform)
                
                # Apply color if exists
                if obj.color:
                    actor.GetProperty().SetColor(obj.color.r, obj.color.g, obj.color.b)
                    actor.GetProperty().SetOpacity(obj.color.a)
                
                # Add to scene
                self.renderer.AddActor(actor)
                self.actors[obj.name] = actor
                
                # Create and emit object properties
                props = ObjectProperties()
                props.name = obj.name
                props.visible = True
                if obj.color:
                    props.color = (obj.color.r, obj.color.g, obj.color.b)
                    props.opacity = obj.color.a
                else:
                    props.color = (0.8, 0.8, 0.8)
                    props.opacity = 1.0
                props.wireframe = False
                props.cast_shadows = True
                props.receive_shadows = True
                
                # Update object tree widget
                self.object_properties_changed.emit(props)
                
                # Update statistics for first object
                if len(self.actors) == 1:
                    self._update_stats(obj.mesh)
            
            # Reset camera
            self.reset_view()
            
            self.model_loaded.emit(True)
            return True
            
        except Exception as e:
            traceback.print_exc()
            print(f"Error loading 3MF: {e}")
            self.model_loaded.emit(False)
            return False

    def clear_scene(self):
        """Clear all actors from the scene"""
        for actor in self.actors.values():
            self.renderer.RemoveActor(actor)
        self.actors.clear()
        self.renderer.GetRenderWindow().Render()

    def reset_view(self):
        """Reset camera to show all actors"""
        if not self.actors:
            return
            
        print("Resetting camera view...")
        
        # Store light positions
        light_positions = {}
        light_focal_points = {}
        for name, light in self._lights.items():
            if light.GetLightType() != light.LightType.HEADLIGHT:
                light_positions[name] = light.GetPosition()
                light_focal_points[name] = light.GetFocalPoint()
        
        # Reset camera
        self.renderer.ResetCamera()
        
        # Get bounds of all actors
        bounds = [0]*6
        self.renderer.ComputeVisiblePropBounds(bounds)
        print(f"Scene bounds: [{', '.join(map(str, bounds))}]")
        
        camera = self.renderer.GetActiveCamera()
        camera.SetViewUp(0, 1, 0)
        
        # Position camera at an angle
        center = [(bounds[1] + bounds[0])/2,
                (bounds[3] + bounds[2])/2,
                (bounds[5] + bounds[4])/2]
                
        radius = max(bounds[1]-bounds[0],
                  bounds[3]-bounds[2],
                  bounds[5]-bounds[4]) * 1.5
                  
        camera.SetPosition(center[0] + radius,
                        center[1] + radius,
                        center[2] + radius)
        camera.SetFocalPoint(*center)
        
        # Restore light positions in world space
        for name, light in self._lights.items():
            if light.GetLightType() != light.LightType.HEADLIGHT:
                if name in light_positions:
                    light.SetPosition(*light_positions[name])
                    light.SetFocalPoint(*light_focal_points[name])
        
        self.renderer.ResetCameraClippingRange()
        pos = camera.GetPosition()
        focal = camera.GetFocalPoint()
        print(f"Camera position: [{', '.join(map(str, pos))}]")
        print(f"Focal point: [{', '.join(map(str, focal))}]")
        
        self.renderer.GetRenderWindow().Render()

    def center_model(self):
        """Center the model in view"""
        if self.actors:
            self.renderer.ResetCamera()
            camera = self.renderer.GetActiveCamera()
            camera.SetViewUp(0, 1, 0)
            self.renderer.GetRenderWindow().Render()

    def set_camera_mode(self, mode: str):
        """Set camera interaction mode"""
        if not self.renderer.GetRenderWindow().GetInteractor():
            return
            
        if mode == 'trackball':
            style = vtk.vtkInteractorStyleTrackballCamera()
            self.renderer.GetRenderWindow().GetInteractor().SetInteractorStyle(style)

    def set_object_visibility(self, name: str, visible: bool):
        """Set object visibility"""
        if name in self.actors:
            self.actors[name].SetVisibility(visible)
            self.renderer.GetRenderWindow().Render()

    def set_object_color(self, name: str, color: tuple):
        """Set object color"""
        if name in self.actors:
            self.actors[name].GetProperty().SetColor(*color)
            self.renderer.GetRenderWindow().Render()

    def set_object_opacity(self, name: str, opacity: float):
        """Set object opacity"""
        if name in self.actors:
            self.actors[name].GetProperty().SetOpacity(opacity)
            self.renderer.GetRenderWindow().Render()

    def set_object_wireframe(self, name: str, wireframe: bool):
        """Set object wireframe mode"""
        if name in self.actors:
            if wireframe:
                self.actors[name].GetProperty().SetRepresentationToWireframe()
            else:
                self.actors[name].GetProperty().SetRepresentationToSurface()
            self.renderer.GetRenderWindow().Render()

    def set_object_shadows(self, name: str, cast: bool, receive: bool):
        """Set object shadow properties"""
        if name not in self.actors:
            return
            
        actor = self.actors[name]
        prop = actor.GetProperty()
        
        # Adjust material properties for shadow effects
        if receive:
            prop.SetAmbient(0.1)
            prop.SetDiffuse(0.9)
            prop.SetSpecular(0.1)
        else:
            prop.SetAmbient(0.5)
            prop.SetDiffuse(0.5)
            prop.SetSpecular(0.0)
        
        # Adjust opacity for shadow casting
        if not cast:
            current_opacity = prop.GetOpacity()
            prop.SetOpacity(min(current_opacity, 0.95))
        
        self.renderer.GetRenderWindow().Render()

    def take_screenshot(self):
        """Take a screenshot"""
        if self.screenshot_tools:
            self.screenshot_tools.capture_screenshot()

    def take_high_res_screenshot(self, scale_factor: int = 4):
        """Take a high-resolution screenshot"""
        if self.screenshot_tools:
            self.screenshot_tools.capture_high_res_screenshot(scale_factor)

    def set_background_color(self, color):
        """Set background color"""
        self.renderer.SetBackground(*color)
        if hasattr(self, '_gradient_enabled') and self._gradient_enabled:
            # Darker gradient color for bottom
            darker = [c * 0.5 for c in color]
            self.renderer.GradientBackgroundOn()
            self.renderer.SetBackground2(*color)  # Top color
            self.renderer.SetBackground(*darker)  # Bottom color
        else:
            self.renderer.GradientBackgroundOff()
            self.renderer.SetBackground(*color)
        self.renderer.GetRenderWindow().Render()

    def set_background_gradient(self, enabled):
        """Enable/disable background gradient"""
        self._gradient_enabled = enabled
        if enabled:
            # Get current background color
            color = self.renderer.GetBackground()
            darker = [c * 0.5 for c in color]
            self.renderer.GradientBackgroundOn()
            self.renderer.SetBackground2(*color)  # Top color
            self.renderer.SetBackground(*darker)  # Bottom color
        else:
            self.renderer.GradientBackgroundOff()
        self.renderer.GetRenderWindow().Render()

    def toggle_light(self, light_type, enabled):
        """Toggle specific light on/off"""
        if not hasattr(self, '_lights'):
            return
        
        if light_type == 'ambient':
            self._lights['ambient'].SetSwitch(enabled)
        elif light_type == 'key':
            self._lights['key'].SetSwitch(enabled)
        elif light_type == 'fill':
            self._lights['fill'].SetSwitch(enabled)
        elif light_type == 'rim':
            self._lights['rim'].SetSwitch(enabled)
        
        self.renderer.GetRenderWindow().Render()

def _setup_lighting(self):
    """Set up scene lighting"""
    # Remove existing lights
    lights = self.renderer.GetLights()
    lights.InitTraversal()
    light = lights.GetNextItem()
    while light:
        self.renderer.RemoveLight(light)
        light = lights.GetNextItem()

    # Store lights in a dictionary for easy access
    self._lights = {}

    # Create ambient light (headlight)
    ambient = vtk.vtkLight()
    ambient.SetLightTypeToHeadlight()
    ambient.SetIntensity(0.3)
    ambient.SetColor(1.0, 1.0, 1.0)
    self.renderer.AddLight(ambient)
    self._lights["ambient"] = ambient

    # Create key light
    key = vtk.vtkLight()
    key.SetLightTypeToSceneLight()
    key.SetPosition(5, 10, 15)
    key.SetFocalPoint(0, 0, 0)
    key.SetColor(1.0, 1.0, 1.0)
    key.SetIntensity(0.6)
    key.SetPositional(True)
    self.renderer.AddLight(key)
    self._lights["key"] = key

    # Create fill light
    fill = vtk.vtkLight()
    fill.SetLightTypeToSceneLight()
    fill.SetPosition(-10, -5, -15)
    fill.SetFocalPoint(0, 0, 0)
    fill.SetColor(0.9, 0.9, 1.0)
    fill.SetIntensity(0.4)
    fill.SetPositional(True)
    self.renderer.AddLight(fill)
    self._lights["fill"] = fill

    # Create rim light
    rim = vtk.vtkLight()
    rim.SetLightTypeToSceneLight()
    rim.SetPosition(-5, 15, -10)
    rim.SetFocalPoint(0, 0, 0)
    rim.SetColor(1.0, 1.0, 0.9)
    rim.SetIntensity(0.3)
    rim.SetPositional(True)
    self.renderer.AddLight(rim)
    self._lights["rim"] = rim
